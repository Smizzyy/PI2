<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.3/new.min.css">
    <title>Hausübung 4: Betriebssysteme</title>
</head>
<body>
    <header>
        <h1>Hausübung 4: Betriebssysteme</h1>
        <p>in <a href="https://moodle.thm.de/course/view.php?id=11780">INF1006 Praktische Informatik 2</a> von <a href="https://www.thm.de/mni/martin-weigel">Prof. Dr. Martin Weigel</a></p>
    </header>

    <main>
        <p>
            In dieser Hausübung bearbeiten Sie Aufgaben rund um das Schichtenmodell, Scheduling und grundlegende Betriebssystemkonzepte. 
            Jede Aufgabe wird separat bewertet, und die Ergebnisse sind vollständig zu dokumentieren.
        </p>

        <div class="section">
            <h2>Aufgabe 1: Programme dem Schichtenmodell zuordnen</h2>
            <p>
                Betriebssysteme basieren oft auf einem Schichtenmodell. Programme interagieren dabei mit verschiedenen Schichten, abhängig von ihrer Funktion und ihrem Zweck.
                Ordnen Sie die folgenden Programme einer passenden Schicht (1-5) im Betriebssystem (siehe Folie 23, Betriebssysteme) zu:
            </p>
            <ul>
                <li>FACEIT Anti-Cheat</li>
                <li>Grafiktreiber</li>
                <li>Fortnite</li>
                <li>Windows Defender</li>
                <li>Shell</li>
            </ul>
            <p>
                Begründen Sie Ihre Zuordnung mit kurzen Erklärungen. Achten Sie darauf, sich auf die im Schichtenmodell beschriebenen Schnittstellen und Aufgaben zu beziehen.
            </p>
        </div>

        <div class="section">
            <h2>Aufgabe 2: Simulation von Round-Robin Scheduling</h2>
            <p>
                Implementieren Sie einen Round-Robin Scheduling-Algorithmus in Java. Die Prozesse werden als vorgegebene Java-Klassen bereitgestellt. 
                Jeder Prozess verfügt über eine <code>run()</code>-Methode, die bei Ausführung eine bestimmte Anzahl von Millisekunden "arbeitet".
                Sie erhalten ebenfalls eine Scheduling-Datei in der Sie den Algorithmus implementieren sollen.
            </p>
            <ol>
                <li>Implementieren Sie einen Scheduler, der die Prozesse in einer zyklischen Reihenfolge ausführt. Jeder Prozess darf für eine vorgegebene Zeitspanne (Zeitscheibe) laufen, bevor er zurück in die Warteschlange gestellt wird.</li>
                <li>
                    Verarbeiten Sie mindestens fünf Prozesse, die unterschiedliche Laufzeiten haben. Dokumentieren Sie die Ausführungsreihenfolge und Zeiten für jeden Prozess.
                    Ändern Sie die Länge der Zeitscheibe und führen Sie die gleichen Prozesse noch einmal aus. Was verändert sich?
                </li>
                <li>Erörtern Sie in einem kurzen Text, inwiefern ihre Implementierung die Eigenschaften eines guten Scheduling-Algorithmus erfüllt.</li>
            </ol>
        </div>

        <div class="section">
            <h2>Aufgabe 3: Deadlocks und Race Conditions</h2>
            <p>
                Mit einem <code>ReentrantLock</code> können Sie das Sperren einer Ressource simulieren.
                Eine Überblick über die Funktionsweise finden Sie auf <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html">Oracle Docs</a> und <a href="https://www.geeksforgeeks.org/reentrant-lock-java/">GeeksforGeeks</a>.
            </p>
            <p>
                Beantworten Sie die folgenden Fragen und lösen Sie die Aufgaben:
            </p>
            <ul>
                <li><strong>Analyse:</strong> Beschreiben Sie, wie es in diesem Code zu <a href="https://de.wikipedia.org/wiki/Deadlock_(Informatik)">Deadlocks</a> und <a href="https://de.wikipedia.org/wiki/Wettlaufsituation">Race Conditions</a> kommen kann. Beziehen Sie sich dabei auf die betroffenen Threads und Ressourcen.</li>
                <li><strong>Lösung:</strong> Beheben Sie die Probleme im Code:
                    <ul>
                        <li>Verhindern Sie Deadlocks zwischen den Threads <code>Task1</code> und <code>Task2</code>.</li>
                        <li>Schützen Sie die Ressource <code>sharedCounter</code>, sodass keine Race Conditions auftreten.</li>
                    </ul>
                </li>
                <li>Erklären Sie kurz, welche Änderungen Sie vorgenommen haben und warum diese Lösungen funktionieren.</li>
                <li>Testen Sie Ihren korrigierten Code: Er sollte eine geordnete Liste von 1 bis 40 ausgeben, sobald die Threads <code>CounterTask</code> ihre Arbeit abgeschlossen haben.</li>
            </ul>
        </div>
        

        <div class="section">
            <h3>Abgabe</h3>
            <ul>
                <li>Ihre Lösungen und Dokumentationen in einer Markdown-Datei</li>
                <li>Ihre Lösungen von Aufgabe 2 & 3 als Java-Dateien</li>
            </ul>
        </div>
    </main>
</body>
</html>
